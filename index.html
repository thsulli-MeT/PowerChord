<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>sMV PowerChord (v4.0)</title>
  <style>
:root { --bg:#0b0f14; --panel:#101824; --ink:#e7eef7; --muted:#9fb0c5; --stroke:#1e2a3a; }
* { box-sizing: border-box; }
body {
  margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: radial-gradient(1200px 600px at 20% 0%, #122035, var(--bg));
  color: var(--ink);
  display: grid; place-items: center;
  min-height: 100vh;
}
.app {
  width: min(1100px, 96vw);
  background: rgba(16,24,36,.78);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 18px;
  overflow: hidden;
  box-shadow: 0 24px 80px rgba(0,0,0,.45);
  backdrop-filter: blur(8px);
}

/* BRAND BAR */
.brandbar{
  display:grid;
  grid-template-columns: 1fr auto 1fr;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  background: rgba(0,0,0,.18);
}
.brandlink{
  display:flex; align-items:center;
}
.brandlink:first-child{ justify-content:flex-start; }
.brandlink:last-child{ justify-content:flex-end; }
.brandbar img{
  height: 44px;
  width: auto;
  filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
}
.brandcenter{
  display:flex; justify-content:center; align-items:center;
}
.brandcenter img{ height: 64px; }

header {
  padding: 14px 16px;
  display: flex; align-items: center; justify-content: space-between;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
header .title { font-weight: 650; letter-spacing:.2px; }
header .hint { color: var(--muted); font-size: 12px; }

.timeline { padding: 10px 12px 10px 12px; border-bottom: 1px solid rgba(255,255,255,.06); }
.lane {
  background: rgba(8,12,18,.65);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 14px;
  padding: 10px 12px 12px 12px;
  position: relative;
  overflow: hidden;
}
.laneTop {
  display:flex; align-items:center; justify-content:space-between;
  margin-bottom: 8px;
  color: var(--muted);
  font-size: 12px;
}
.blocks {
  height: 44px;
  border-radius: 10px;
  background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  position: relative;
  overflow: hidden;
  margin-bottom: 10px;
}
.ticks{
  position:absolute;
  inset: 0;
  pointer-events:none;
}
.tick{
  position:absolute;
  top:0; bottom:0;
  width:1px;
  background: rgba(255,255,255,.12);
}
.tick.major{
  background: rgba(255,255,255,.22);
  width: 2px;
}
.tickLabel{
  position:absolute;
  top: 2px;
  transform: translateX(4px);
  font-size: 10px;
  color: rgba(255,255,255,.45);
}
.playhead {
  position:absolute; top:0; bottom:0; width:2px;
  background: rgba(255,255,255,.65);
  transform: translateX(0);
  pointer-events:none;
  box-shadow: 0 0 14px rgba(255,255,255,.35);
}
.loopBadge {
  position:absolute; left:10px; top:10px;
  padding: 3px 8px;
  border-radius: 999px;
  background: rgba(0,0,0,.35);
  border: 1px solid rgba(255,255,255,.08);
  font-size: 12px;
  color: var(--ink);
}

.tracksHeader{
  display:flex; align-items:center; justify-content:space-between;
  padding: 6px 2px 8px 2px;
}
.tracksTitle{ font-weight: 650; color: rgba(255,255,255,.85); }
.tracksActions{ display:flex; gap:8px; align-items:center; }

.tracks{
  display:grid;
  gap:8px;
}
.trackRow{
  display:grid;
  grid-template-columns: 1.2fr 1.1fr 1.1fr 1fr;
  gap:8px;
  align-items:center;
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.06);
  background: rgba(255,255,255,.04);
}
.trackName{
  display:flex; align-items:center; gap:10px;
}
.dot{
  width: 10px; height: 10px; border-radius: 50%;
  background: rgba(255,255,255,.55);
  box-shadow: 0 0 12px rgba(255,255,255,.15);
}
.trackMeta{
  color: var(--muted);
  font-size: 12px;
}
.trackBtns{
  display:flex; gap:8px; justify-content:flex-end; align-items:center; flex-wrap:wrap;
}
.trackCtl{
  display:flex; gap:8px; align-items:center; justify-content:flex-start; flex-wrap:wrap;
}
.trackCtl select, .trackCtl input[type="range"]{
  width: 100%;
  max-width: 260px;
}
.smallLabel{ font-size: 12px; color: var(--muted); }

.controls {
  padding: 10px 12px;
  display: grid;
  grid-template-columns: 1.4fr 1fr 1fr 1fr 1fr 1fr;
  gap: 10px;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.ctl {
  background: rgba(8,12,18,.55);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 14px;
  padding: 10px 12px;
  display: grid;
  gap: 6px;
}
.ctl label { font-size: 12px; color: var(--muted); }
select, input[type="number"], input[type="range"] {
  width: 100%;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.08);
  color: var(--ink);
  border-radius: 10px;
  padding: 8px 10px;
  outline: none;
}
input[type="range"] { padding: 10px 0; }
.transport { display:flex; gap:10px; align-items: center; flex-wrap:wrap; }

.btn {
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--ink);
  border-radius: 14px;
  padding: 10px 12px;
  cursor: pointer;
  user-select:none;
  transition: transform .08s ease, background .18s ease;
  font-weight: 600;
  white-space: nowrap;
}
.btn.small{ padding: 8px 10px; border-radius: 12px; font-weight: 650; }
.btn:active { transform: translateY(1px); }
.btn.primary { background: rgba(52, 211, 153, .18); border-color: rgba(52,211,153,.35); }
.btn.danger { background: rgba(239, 68, 68, .16); border-color: rgba(239,68,68,.35); }
.btn.on { outline: 2px solid rgba(255,255,255,.22); }
.btn.arm.on { background: rgba(52,211,153,.16); border-color: rgba(52,211,153,.35); }
.btn.mute.on{ background: rgba(245,158,11,.16); border-color: rgba(245,158,11,.35); }
.btn.clear{ background: rgba(255,255,255,.06); }

.padsWrap { padding: 12px; display: grid; gap: 10px; }
.pads { display:grid; grid-template-columns: repeat(8, 1fr); gap: 10px; }
.pad {
  height: 96px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  display:grid;
  align-content: center;
  justify-items: center;
  gap: 6px;
  cursor:pointer;
  user-select:none;
  position: relative;
  overflow:hidden;
  transition: transform .08s ease, filter .18s ease;
  touch-action: none;
}
.pad:active { transform: translateY(1px) scale(.99); }
.pad .name { font-size: 22px; font-weight: 800; letter-spacing: .2px; }
.pad .notes { font-size: 12px; color: rgba(255,255,255,.75); }
.pad .kbd { position:absolute; top:10px; right:10px; font-size: 12px; color: rgba(255,255,255,.75); }
.pad.active { filter: brightness(1.18); }

.subbar {
  display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
  color: var(--muted);
  font-size: 12px;
  padding: 0 16px 16px 16px;
}
.status { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
.pill {
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.25);
  color: rgba(255,255,255,.80);
}

@media (max-width: 980px) {
  .controls { grid-template-columns: 1fr 1fr; }
  .pads { grid-template-columns: repeat(4, 1fr); }
  .pad { height: 110px; }
  .trackRow { grid-template-columns: 1fr; }
  .trackBtns { justify-content:flex-start; }
  .brandbar{ grid-template-columns: 1fr; justify-items:center; }
  .brandlink:first-child, .brandlink:last-child{ justify-content:center; }
}

.viz{
  padding: 8px 12px 0 12px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  display:grid;
  gap:10px;
}
.vizTop{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:12px;
}
.vizTitle{ font-weight:650; color: rgba(255,255,255,.86); }
.vizHint{ color: var(--muted); font-size:12px; }
canvas{
  width: 100%;
  background: rgba(0,0,0,.28);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 12px;
}
.row{ display:flex; align-items:center; justify-content:center; }
.check{
  display:flex; align-items:center; gap:10px;
  font-size: 13px;
  color: rgba(255,255,255,.86);
  user-select:none;
}
.check input{ transform: scale(1.15); }

.vizRow{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
  padding: 10px 14px 10px 14px;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.vizLeft,.vizRight{ display:grid; gap:6px; align-content:start; }
.vizTitle{ font-weight:650; color: rgba(255,255,255,.78); font-size:12px; letter-spacing:.2px; }
.vizRow canvas{
  width:100%;
  background: rgba(0,0,0,.26);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 12px;
}

@media (max-width: 980px){
  .vizRow{ grid-template-columns: 1fr; }
}

/* v3.1 sound test: compact 2-row top */
.controlsBar{ padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,.06); }
.transportBar{
  display:flex; flex-wrap:wrap; align-items:center; gap:8px;
  background: rgba(8,12,18,.55);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 16px;
  padding: 10px 12px;
}
.mini{ display:grid; gap:4px; }
.miniLabel{ font-size:11px; color: rgba(255,255,255,.62); }
.transportBar input[type="number"], .transportBar select{
  width: 92px; padding: 7px 8px; border-radius: 10px;
}
.transportBar input[type="range"]{ width: 140px; }
.miniCheck{ display:flex; align-items:center; gap:8px; font-size:12px; color: rgba(255,255,255,.82); user-select:none; }
.miniCheck input{ transform: scale(1.1); }

/* tighten tracks */
.tracks{ padding: 8px 12px; }
.trackRow{ padding: 6px 8px; }
.trackName{ font-size: 13px; }
.trackCtl{ gap:6px !important; }
.trackCtl select{ width: 140px; padding: 6px 8px; }
.trackCtl input[type="range"]{ width: 100px; }
.trackBtns .btn{ padding: 6px 8px; border-radius: 10px; }
.pad{ height: 88px; }

/* v3.2 Circle of Fifths panel */
.topHeader{
  display:flex;
  gap:12px;
  align-items:flex-start;
  justify-content:space-between;
  padding: 10px 12px 8px 12px;
}
.headerLeft{ min-width: 340px; }
.learnPanel{
  width: 240px;
  background: rgba(8,12,18,.55);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 16px;
  padding: 10px 10px 8px 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
.learnTop{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}
.learnLabel{
  font-size:12px;
  color: rgba(255,255,255,.72);
}
.learnChord{
  font-size:18px;
  font-weight:800;
  letter-spacing:.2px;
}
#circleSvg{ width: 100%; height: auto; display:block; }
.c5-seg{ fill: rgba(255,255,255,.06); stroke: rgba(255,255,255,.10); stroke-width: 1; transition: .12s; }
.c5-seg.active{ fill: rgba(59,130,246,.28); stroke: rgba(59,130,246,.55); }
.c5-text{ fill: rgba(255,255,255,.78); font-size: 12px; font-weight: 700; }
.c5-center{
  fill: rgba(255,255,255,.88);
  font-size: 24px;
  font-weight: 900;
}
.c5-sub{
  fill: rgba(255,255,255,.70);
  font-size: 12px;
  font-weight: 700;
}
@media (max-width: 980px){
  .topHeader{ flex-direction:column; align-items:stretch; }
  .learnPanel{ width: 100%; max-width: 420px; }
}

/* v3.3 layout fix: remove big empty grid space in controls bar */
.controlsBar{ display:block !important; }
.controlsBar .transportBar{ width: 100%; justify-content:flex-start; }

.transportBar{ gap:10px; }

.patternBox{ display:grid; gap:6px; padding: 0 6px; }
.patternBtns{ display:flex; gap:6px; }
.patternBtns .btn{ padding: 6px 10px; border-radius: 10px; }

/* v3.3.1: move Circle of Fifths into vizRow */
.topHeader.noLearn{ justify-content:flex-start; }
.vizRow{ display:flex; gap:12px; align-items:stretch; flex-wrap:wrap; }
.vizLeft, .vizRight{ flex: 1 1 320px; }
.vizLearn{
  flex: 0 0 220px;
  background: rgba(8,12,18,.55);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 16px;
  padding: 10px 10px 8px 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  display:grid;
  grid-template-rows: auto auto 1fr;
  gap:6px;
  align-content:start;
}
.vizLearn .vizTitle{ margin:0; }
.vizLearn .learnChord{ font-size:20px; font-weight:900; text-align:center; }
.vizLearn #circleSvg{ width:100%; height:auto; }

.padMode{
  margin: 6px 0 10px 2px;
  font-size: 12px;
  font-weight: 800;
  letter-spacing: .18em;
  color: rgba(255,255,255,.70);
  text-transform: uppercase;
}
.padMode.drum{ color: rgba(59,130,246,.85); }

/* v3.4 monitors row */
.monitorRow{
  display:flex;
  gap:10px;
  padding: 6px 12px 4px 12px;
  align-items:center;
}
.monitorBox{
  background: rgba(8,12,18,.55);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: 14px;
  padding: 8px 10px 8px 10px;
  display:grid;
  gap:6px;
}
.monitorBox.grow{ flex: 1 1 auto; min-width: 280px; }
.monitorBox.c5{ width: 240px; }
.monitorTitle{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: rgba(255,255,255,.65);
}
#meter, #analyzer{ display:block; width: 100%; height: 32px; }
.c5Wrap{ position: relative; }
.c5Wrap .learnChord{
  position:absolute; top: 10px; left: 50%; transform: translateX(-50%);
  font-size: 18px; font-weight: 900; background: rgba(0,0,0,.35);
  padding: 4px 10px; border-radius: 999px;
}
#circleSvg{ width: 100%; height: auto; display:block; margin-top: 14px; }
@media (max-width: 980px){
  .monitorRow{ flex-wrap:wrap; }
  .monitorBox.c5{ width: 100%; max-width: 420px; }
}

/* v3.6.2 UI sanity */
.sanityBanner{
  margin: 10px 12px 0 12px;
  padding: 10px 12px;
  border-radius: 16px;
  background: rgba(16,185,129,.10);
  border: 1px solid rgba(16,185,129,.25);
  color: rgba(255,255,255,.92);
  font-weight: 700;
}
.padModeRow{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
.padModeHint{ font-size: 12px; color: rgba(255,255,255,.55); }
.padCounter{ margin: 8px 0 10px 2px; font-size: 12px; color: rgba(255,255,255,.75); }
.padRowTitle{
  margin: 10px 0 8px 2px;
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: rgba(255,255,255,.65);
}
#padGridMaj, #padGridMin, #padGridDrums{
  display:grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap:10px;
}
.pad{ height: 78px; }
.pad.drum{ background: rgba(255,255,255,.05); border: 1px solid rgba(255,255,255,.08); }


/* v4.0 layout: single-screen 24-pad grid */
html, body { height: 100%; overflow: hidden; }
.app { height: 100vh; overflow: hidden; }
.padsWrap { padding: 10px 14px 12px; }
.padRows { display: flex; flex-direction: column; gap: 10px; }
.padRow { display: grid; grid-template-columns: 46px 1fr; gap: 10px; align-items: stretch; }
.rowLabel { display:flex; align-items:center; justify-content:center; color: var(--muted); font-weight: 650; border: 1px solid var(--stroke); background: rgba(16,24,36,0.45); border-radius: 10px; }
.pads { display: grid; grid-template-columns: repeat(8, minmax(0, 1fr)); gap: 10px; }
.pad { min-height: 84px; }
.controlsBar .transportBar { flex-wrap: nowrap; overflow: hidden; }
.vizRow { align-items: center; }
.tracks .trackRow { grid-template-columns: 1fr; }

/* v4.0 compact tracks */
.trackRowCompact{
  display:grid;
  grid-template-columns: 1.4fr 52px 38px 92px 150px 50px 1fr 1fr 46px 54px;
  gap: 8px;
  align-items:center;
  padding: 8px 8px;
  border: 1px solid var(--stroke);
  border-left: 4px solid;
  border-radius: 12px;
  background: rgba(16,24,36,0.35);
}
.trackRowCompact .tName{ display:flex; align-items:center; gap:8px; font-weight:650; }
.trackRowCompact .tHits{ color: var(--muted); text-align:center; font-variant-numeric: tabular-nums; }
.tinySel{ width:100%; padding:6px 8px; border-radius:10px; background:#0d1420; color:var(--ink); border:1px solid var(--stroke); }
.tinyRange{ width:100%; }
.btn.tiny{ padding:6px 10px; border-radius:10px; font-size:12px; }
.btn.tiny.on{ outline: 1px solid rgba(255,255,255,0.35); }
</style>
</head>
<body>
  <div class="app">
    <div class="brandbar">
      <a class="brandlink" href="https://shortmusicvideos.com" target="_blank" rel="noopener">
        <img src="./assets/img/smv.png" alt="sMV" />
      </a>
      <div class="brandcenter" title="PowerChord">
        <img src="./assets/img/powerchord.png" alt="PowerChord" />
      </div>
      <a class="brandlink" href="https://thsulli-met.github.io/Power-Mix/" target="_blank" rel="noopener">
        <img src="./assets/img/powermix.png" alt="Power Mix" />
      </a>
    </div>

    
<header class="topHeader noLearn">
  <div class="headerLeft">
    <div class="title">sMV PowerChord — v4.0 (24-pad UI sanity)</div>
    <div class="hint">Pads: 1–8 Maj • Q–I Min • A–K Drums • Space: Play/Stop • R: Record • Esc: Panic</div>
  </div>
</header>
<div class="sanityBanner">✅ UI SANITY CHECK: This build MUST show <b>24 pads</b> (8 Major + 8 Minor + 8 Drums). If you don't see them, you're not loading this folder.</div>



    <section class="timeline">
      <div class="lane">
        <div class="laneTop">
          <div>Looper</div>
          <div id="loopInfo">Loop: 4 bars • Quantize: ON</div>
        </div>
        <div class="blocks" id="blocks">
          <div class="ticks" id="ticks"></div>
          <div class="loopBadge" id="loopBadge">EMPTY</div>
          <div class="playhead" id="playhead"></div>
        </div>

        <div class="tracksHeader">
          <div class="tracksTitle">Tracks</div>
          <div class="tracksActions">
            <button class="btn" id="addTrackBtn">＋ Track</button>
            <button class="btn" id="clearAllBtn">Clear All</button>
          </div>
        </div>

        <div id="tracks" class="tracks"></div>
      </div>
    </section>

    
<section class="controls controlsBar">
  <div class="transportBar">
    <button class="btn primary" id="playBtn">▶</button>
    <button class="btn danger" id="stopBtn">■</button>
    <button class="btn" id="recBtn">●</button>
    <button class="btn" id="exportBtn">⬇ WAV</button>
    <button class="btn danger" id="panicBtn">⛔</button>

    <div class="patternBox" title="Fill a drum track with a starter groove">
      <div class="miniLabel">Drums</div>
      <div class="patternBtns">
        <button class="btn" id="rockBtn">Rock</button>
        <button class="btn" id="hiphopBtn">HipHop</button>
      </div>
    </div>

    <div class="mini"><div class="miniLabel">BPM</div><input id="bpm" type="number" min="60" max="180" value="100"/></div>
    <div class="mini"><div class="miniLabel">Bars</div><select id="barsSel">
      <option value="1">1</option><option value="2">2</option><option value="4" selected>4</option>
      <option value="8">8</option><option value="16">16</option><option value="32">32</option></select></div>
    <div class="mini"><div class="miniLabel">Key</div><select id="keySel">
      <option value="C" selected>C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
      <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
      <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option></select></div>
    <div class="mini"><div class="miniLabel">Room</div><input id="rev" type="range" min="0" max="1" step="0.01" value="0.22"/></div>

    <label class="miniCheck" title="Output limiter + auto-duck"><input id="safeMode" type="checkbox" checked/><span>Safe</span></label>
    <div class="audioState" id="audioState">Audio: off</div>
  </div>
</section>


    
    <section class="vizRow">
      <div class="vizLeft">
        <div class="vizTitle">Output</div>
        <canvas id="meter" width="420" height="18"></canvas>
      </div>
      <div class="vizRight">
        <div class="vizTitle">Spectrum</div>
        <canvas id="spectrum" width="420" height="70"></canvas>
      </div>
    
<div class="vizLearn">
  <div class="vizTitle">Circle of Fifths</div>
  <div class="learnChord" id="learnChord">—</div>
  <svg id="circleSvg" viewBox="0 0 220 220" role="img" aria-label="Circle of Fifths diagram"></svg>
</div>

    </section>
<section class="padsWrap">
  <div class="padRows">
    <div class="padRow">
      <div class="rowLabel">Maj</div>
      <div class="pads" id="padGridMaj"></div>
    </div>
    <div class="padRow">
      <div class="rowLabel">Min</div>
      <div class="pads" id="padGridMin"></div>
    </div>
    <div class="padRow">
      <div class="rowLabel">Drm</div>
      <div class="pads" id="padGridDrm"></div>
    </div>
  </div>
</section>

    <div class="subbar">
      <div class="status">
        <span class="pill" id="audioPill">Audio: off (click a pad)</span>
        <span class="pill" id="modePill">Mode: Play</span>
        <span class="pill" id="armedPill">Armed: Track 1</span>
        <span class="pill" id="lastChord">Last: —</span>
      </div>
      <div class="pill">Hold pads to sustain • Bounce exports one loop cycle</div>
    </div>
  </div>

  <script>
(function() {
  const errBox = document.getElementById("audioState");
  function showErr(e){
    const msg = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
    if (errBox) errBox.textContent = "Error: " + msg;
  }
  window.addEventListener("error", (ev)=>{
    // Try to surface something better than Script error.
    if (ev && ev.error) showErr(ev.error);
    else if (errBox) errBox.textContent = "Error: " + (ev.message || "Unknown");
  });
  window.addEventListener("unhandledrejection", (ev)=>{ showErr(ev.reason); });

  try {
window.onerror = function(msg, src, line, col){
  try{ const el=document.getElementById('audioState'); if(el) el.textContent = 'Error: ' + msg + ' @' + line + ':' + col; }catch(_){ }
};


function buildLimiterChain(ctx, source){
  // Compressor -> soft clipper
  comp = ctx.createDynamicsCompressor();
  comp.threshold.value = -18;
  comp.knee.value = 20;
  comp.ratio.value = 10;
  comp.attack.value = 0.003;
  comp.release.value = 0.25;

  shaper = ctx.createWaveShaper();
  const curve = new Float32Array(65536);
  for (let i=0;i<curve.length;i++){
    const x = (i / 32768) - 1;
    // softer than before
    curve[i] = Math.tanh(1.8 * x);
  }
  shaper.curve = curve;
  shaper.oversample = "4x";

  // analysers (spectrum + level)
  analyser = ctx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.86;

  meterAnalyser = ctx.createAnalyser();
  meterAnalyser.fftSize = 1024;
  meterAnalyser.smoothingTimeConstant = 0.4;

  source.connect(comp);
  comp.connect(shaper);
  shaper.connect(analyser);
  analyser.connect(meterAnalyser);
  meterAnalyser.connect(ctx.destination);
}


function addSoftLimiter(ctx, input){
  const shaper = ctx.createWaveShaper();
  const curve = new Float32Array(65536);
  for (let i=0;i<curve.length;i++){
    const x = (i / 32768) - 1;
    curve[i] = Math.tanh(2.5 * x);
  }
  shaper.curve = curve;
  shaper.oversample = "4x";
  input.connect(shaper);
  shaper.connect(ctx.destination);
  return shaper;
}

// sMV PowerChord — MVP v2.3
// Fixes:
// - Removes "weird flavor" caused by duplicate scheduling and mismatched monitor vs playback
// - Live monitor uses armed track role + volume (matches playback/export)
// - Playback scheduling: schedule each event once per loop occurrence

const DEGREE_QUAL = ["maj","min","min","maj","maj","min","dim","maj"];
const NOTE_NAMES  = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const MAJOR_SCALE = [0,2,4,5,7,9,11];
const TRIADS = { maj:[0,4,7], min:[0,3,7], dim:[0,3,6] };

// 24-pad layout helpers
const DRUMS = [
  { label:"Kick",  drumType:"kick",  sub:"Low thump" },
  { label:"Snare", drumType:"snare", sub:"Crack" },
  { label:"Hat",   drumType:"hat",   sub:"Closed" },
  { label:"Open",  drumType:"ohat",  sub:"Open hat" },
  { label:"Clap",  drumType:"clap",  sub:"Hands" },
  { label:"Tom L", drumType:"tom",   sub:"Low" },
  { label:"Tom H", drumType:"tom2",  sub:"High" },
  { label:"Crash", drumType:"crash", sub:"Noise" },
];

function makeChordPadDef(id, rootName, qual, tag){
  const tri = TRIADS[qual] || TRIADS.maj;
  const rootSemis = NOTE_NAMES.indexOf(rootName);
  const midiRoot = 48 + rootSemis; // C3-ish base
  const midis = tri.map(x => midiRoot + x);
  const freqs = midis.map(mtof);
  const label = formatChordLabel(rootName, qual);
  const notes = midis.map(m => NOTE_NAMES[m % 12]).join(" - ");
  return { id, kind:"chord", qual, rootName, label, symbol: chordSymbol(rootName, qual), notes, freqs, rootMidi: midiRoot, sub: notes };
}

function makeDrumPadDef(id, d){
  return { id, kind:"drum", drumType:d.drumType, label:d.label, sub:d.sub };
}

function getPadDef(padId, keyName){
  // Recompute from current key so labels stay correct after key change
  const tonicIdx = NOTE_NAMES.indexOf(keyName);
  if (padId >= 0 && padId < 8){
    const rootSemis = (tonicIdx + (padId * 7)) % 12;
    return makeChordPadDef(padId, NOTE_NAMES[rootSemis], "maj", "M");
  }
  if (padId >= 8 && padId < 16){
    const step = padId - 8;
    const rootSemisMaj = (tonicIdx + (step * 7)) % 12;
    const rootSemisMin = (rootSemisMaj + 9) % 12;
    return makeChordPadDef(padId, NOTE_NAMES[rootSemisMin], "min", "m");
  }
  if (padId >= 16 && padId < 24){
    return makeDrumPadDef(padId, DRUMS[padId-16]);
  }
  return null;
}

function pickTrackForPad(def, armed){
  if (!def) return armed || tracks[0] || null;
  if (def.kind === "drum"){
    if (armed && armed.role === "drums") return armed;
    const t = tracks.find(x => x.role === "drums");
    return t || armed || null;
  }
  // chord
  if (armed && armed.role !== "drums") return armed;
  const t = tracks.find(x => x.role !== "drums");
  return t || armed || null;
}

function prettyAccidentals(s){ return (s||"").replaceAll("#","♯"); }
function chordSymbol(rootName, qual){
  const r = prettyAccidentals(rootName);
  if (qual === "min") return r + "m";
  if (qual === "dim") return r + "°";
  return r; // maj
}


const KBD_KEYS_MAJ = ["1","2","3","4","5","6","7","8"];
const KBD_KEYS_MIN = ["q","w","e","r","t","y","u","i"];
const KBD_KEYS_DRM = ["a","s","d","f","g","h","j","k"];
const PAD_COLORS = [
  "linear-gradient(135deg, rgba(59,130,246,.45), rgba(59,130,246,.14))",
  "linear-gradient(135deg, rgba(16,185,129,.45), rgba(16,185,129,.14))",
  "linear-gradient(135deg, rgba(34,197,94,.45), rgba(34,197,94,.14))",
  "linear-gradient(135deg, rgba(234,179,8,.45), rgba(234,179,8,.14))",
  "linear-gradient(135deg, rgba(249,115,22,.48), rgba(249,115,22,.14))",
  "linear-gradient(135deg, rgba(236,72,153,.40), rgba(236,72,153,.14))",
  "linear-gradient(135deg, rgba(168,85,247,.45), rgba(168,85,247,.14))",
  "linear-gradient(135deg, rgba(59,130,246,.40), rgba(59,130,246,.12))",
];

// UI
const padGridMaj = document.getElementById("padGridMaj");
  const padGridMin = document.getElementById("padGridMin");
  const padGridDrm = document.getElementById("padGridDrm");
const padModeLabel = document.getElementById("padModeLabel");
const tracksEl = document.getElementById("tracks");
const addTrackBtn = document.getElementById("addTrackBtn");
const clearAllBtn = document.getElementById("clearAllBtn");

const keySel = document.getElementById("keySel");
const soundSel = document.getElementById("soundSel");
const bpmEl  = document.getElementById("bpm");
const barsSel= document.getElementById("barsSel");
const revEl  = document.getElementById("rev");
const learnChordEl = document.getElementById("learnChord");
const meterEl = document.getElementById("meter");
const analyzerEl = document.getElementById("analyzer");
const circleSvg = document.getElementById("circleSvg");

const playBtn= document.getElementById("playBtn");
const stopBtn= document.getElementById("stopBtn");
const recBtn = document.getElementById("recBtn");
const exportBtn = document.getElementById("exportBtn");
const panicBtn = document.getElementById("panicBtn");
const rockBtn = document.getElementById("rockBtn");
const hiphopBtn = document.getElementById("hiphopBtn");
const safeModeEl = document.getElementById("safeMode");
const meterCv = document.getElementById("meter");
const spectrumCv = document.getElementById("spectrum");

const audioState = document.getElementById("audioState");
const modePill   = document.getElementById("modePill");
const armedPill  = document.getElementById("armedPill");
const lastChord  = document.getElementById("lastChord");
const loopBadge  = document.getElementById("loopBadge");
const loopInfo   = document.getElementById("loopInfo");
const playhead   = document.getElementById("playhead");
const blocks     = document.getElementById("blocks");

const ticksEl   = document.getElementById("ticks");

function renderTicks(){
  if (!ticksEl || !blocks) return;
  const b = bars();
  // show at most 32 labels, but ticks for each bar and major for each 4
  ticksEl.innerHTML = "";
  for (let i=0;i<=b;i++){
    const x = (i / b) * 100;
    const t = document.createElement("div");
    t.className = "tick" + ((i % 4 === 0) ? " major" : "");
    t.style.left = x + "%";
    ticksEl.appendChild(t);
    if (i < b && (i % 4 === 0)){
      const lab = document.createElement("div");
      lab.className = "tickLabel";
      lab.style.left = x + "%";
      lab.textContent = String(i+1);
      ticksEl.appendChild(lab);
    }
  }
}
window.addEventListener("resize", () => { renderTicks(); });


// Audio
let ac = null;
let safeMode = true;
let limiterIn = null;
let comp = null;
let shaper = null;
let analyser = null;
let meterAnalyser = null;
let vizTimer = null;
let master = null;
let wet = null, dry = null;
let convolver = null;

// Transport
let isPlaying = false;
let isRecording = false;
let loopStartTime = 0;
let playTimer = null;
let rafId = null;

// Tracks
let tracks = []; // {id,name,color,role,events:[], muted:false, armed:false, vol:0..1}
let armedTrackId = null;

// Pads
let padButtons = [];
let activeHolds = new Map(); // pointerId -> { stopFn, recEventId?, trackId?, startBeat? }
let nextEventId = 1;

// helpers
function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }


function drumHit(ctx, outDry, outWet, type, when, vol=1.0, revSend=0.15){
  const t0 = when ?? ctx.currentTime;
  const v = clamp(vol, 0, 1);

  // simple send split
  const dryG = ctx.createGain();
  const wetG = ctx.createGain();
  dryG.gain.value = v;
  wetG.gain.value = v * revSend;
  dryG.connect(outDry);
  wetG.connect(outWet);

  if (type === "kick"){
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(130, t0);
    o.frequency.exponentialRampToValueAtTime(48, t0 + 0.09);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.95, t0 + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
    o.connect(g);
    g.connect(dryG);
    g.connect(wetG);
    o.start(t0); o.stop(t0 + 0.25);
    return;
  }

  if (type === "snare"){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.18);
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass"; hp.frequency.setValueAtTime(900, t0);
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass"; bp.frequency.setValueAtTime(1800, t0); bp.Q.setValueAtTime(0.9, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.9, t0 + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);
    n.connect(hp); hp.connect(bp); bp.connect(g);
    g.connect(dryG); g.connect(wetG);
    n.start(t0); n.stop(t0 + 0.20);

    // little body tone
    const o = ctx.createOscillator();
    const og = ctx.createGain();
    o.type = "triangle";
    o.frequency.setValueAtTime(220, t0);
    og.gain.setValueAtTime(0.0001, t0);
    og.gain.exponentialRampToValueAtTime(0.35, t0 + 0.005);
    og.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);
    o.connect(og); og.connect(dryG);
    o.start(t0); o.stop(t0 + 0.14);
    return;
  }

  if (type === "hat"){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.06);
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass"; hp.frequency.setValueAtTime(7000, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.55, t0 + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.045);
    n.connect(hp); hp.connect(g);
    g.connect(dryG);
    n.start(t0); n.stop(t0 + 0.07);
    return;
  }

  if (type === "clap"){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.12);
    const bp = ctx.createBiquadFilter();
    bp.type="bandpass"; bp.frequency.setValueAtTime(1900, t0); bp.Q.setValueAtTime(1.2, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.85, t0 + 0.003);
    // multi-hit feel
    g.gain.setValueAtTime(0.35, t0 + 0.020);
    g.gain.setValueAtTime(0.60, t0 + 0.032);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.11);
    n.connect(bp); bp.connect(g);
    g.connect(dryG); g.connect(wetG);
    n.start(t0); n.stop(t0 + 0.14);
    return;
  if (type === "ohat"){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.22);
    const hp = ctx.createBiquadFilter(); hp.type="highpass"; hp.frequency.setValueAtTime(5500, t0); hp.Q.setValueAtTime(0.7, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.35, t0 + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
    n.connect(hp); hp.connect(g);
    g.connect(dryG); g.connect(wetG);
    n.start(t0); n.stop(t0 + 0.24);
    return;
  }
  if (type === "tom" || type === "tom2"){
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    const f0 = (type === "tom2") ? 220 : 140;
    o.frequency.setValueAtTime(f0, t0);
    o.frequency.exponentialRampToValueAtTime(f0*0.75, t0 + 0.10);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.70, t0 + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.24);
    o.connect(g); g.connect(dryG); g.connect(wetG);

    // click/noise
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.03);
    const bp = ctx.createBiquadFilter(); bp.type="bandpass"; bp.frequency.setValueAtTime(1800, t0); bp.Q.setValueAtTime(1.6, t0);
    const ng = ctx.createGain(); ng.gain.setValueAtTime(0.20, t0); ng.gain.exponentialRampToValueAtTime(0.0001, t0+0.05);
    n.connect(bp); bp.connect(ng); ng.connect(dryG); ng.connect(wetG);
    o.start(t0); o.stop(t0 + 0.26);
    n.start(t0); n.stop(t0 + 0.06);
    return;
  }
  if (type === "crash"){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.50);
    const hp = ctx.createBiquadFilter(); hp.type="highpass"; hp.frequency.setValueAtTime(3500, t0); hp.Q.setValueAtTime(0.7, t0);
    const bp = ctx.createBiquadFilter(); bp.type="bandpass"; bp.frequency.setValueAtTime(8000, t0); bp.Q.setValueAtTime(0.8, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.60, t0 + 0.006);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.48);
    n.connect(hp); hp.connect(bp); bp.connect(g);
    g.connect(dryG); g.connect(wetG);
    n.start(t0); n.stop(t0 + 0.55);
    return;
  }

  // fallback: do nothing
}


function makeNoiseBuffer(ctx, durationSec=0.03){
  const len = Math.max(1, Math.floor(ctx.sampleRate * durationSec));
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i=0;i<len;i++){
    const t = i/len;
    d[i] = (Math.random()*2-1) * (1 - t) * (1 - t);
  }
  return buf;
}

function makeWaveshaper(ctx, drive=1.2){
  const sh = ctx.createWaveShaper();
  const n = 65536;
  const curve = new Float32Array(n);
  for (let i=0;i<n;i++){
    const x = (i/(n/2)) - 1;
    curve[i] = Math.tanh(drive * x);
  }
  sh.curve = curve;
  sh.oversample = "4x";
  return sh;
}

// Additive harmonic voice with envelope + optional resonator + optional transient noise
function harmonicVoice(ctx, outDry, outWet, freq, when, durSec, vol, p){
  const t0 = when ?? ctx.currentTime;
  const v = clamp(vol ?? 1, 0, 1);

  const env = ctx.createGain();
  env.gain.setValueAtTime(0.0001, t0);
  env.gain.exponentialRampToValueAtTime(Math.max(0.0002, (p.peak ?? 0.9) * v), t0 + (p.attack ?? 0.006));
  env.gain.exponentialRampToValueAtTime(Math.max(0.0002, (p.sustain ?? 0.35) * v), t0 + (p.attack ?? 0.006) + (p.decay ?? 0.20));

  // shared filter
  const lp = ctx.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.setValueAtTime(p.cutoff ?? 2200, t0);
  lp.Q.setValueAtTime(p.lpQ ?? 0.7, t0);

  // optional body resonator chain (peaking filters)
  let last = lp;
  if (p.res && p.res.length){
    p.res.forEach((r)=>{
      const b = ctx.createBiquadFilter();
      b.type = "peaking";
      b.frequency.setValueAtTime(r.f, t0);
      b.Q.setValueAtTime(r.q ?? 1.2, t0);
      b.gain.setValueAtTime(r.g, t0);
      last.connect(b);
      last = b;
    });
  }

  // optional drive
  if (p.drive && p.drive > 0){
    const sh = makeWaveshaper(ctx, 1.0 + 2.0*p.drive);
    last.connect(sh);
    last = sh;
  }

  // per-note reverb send already handled outside; here just connect
  env.connect(lp);
  last.connect(outDry);
  last.connect(outWet);

  const harmonics = p.harm ?? [1,0.4,0.25,0.15,0.08];
  const types = p.types ?? ["triangle","triangle","triangle","triangle","sine"];
  const det = p.detune ?? 0;
  const oscs = [];
  for (let i=0;i<harmonics.length;i++){
    const amp = harmonics[i];
    if (amp <= 0) continue;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = types[Math.min(i, types.length-1)];
    osc.frequency.setValueAtTime(freq * (i+1), t0);
    osc.detune.setValueAtTime((i-2)*det, t0);
    g.gain.setValueAtTime((p.voiceGain ?? 0.20) * amp, t0);
    osc.connect(g);
    g.connect(env);
    osc.start(t0);
    oscs.push(osc);
  }

  // transient noise (hammer/pick)
  if (p.noise && p.noise > 0){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, p.noiseDur ?? 0.015);
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(p.noiseF ?? 2500, t0);
    bp.Q.setValueAtTime(p.noiseQ ?? 1.8, t0);
    const ng = ctx.createGain();
    ng.gain.setValueAtTime(p.noise * v, t0);
    ng.gain.exponentialRampToValueAtTime(0.0001, t0 + (p.noiseDur ?? 0.015));
    n.connect(bp); bp.connect(ng); ng.connect(env);
    n.start(t0);
    n.stop(t0 + (p.noiseDur ?? 0.015) + 0.02);
  }

  const stopAt = t0 + (durSec ?? 1.2);
  env.gain.exponentialRampToValueAtTime(0.0001, stopAt + (p.release ?? 0.50));
  oscs.forEach(o=>{ try{o.stop(stopAt + (p.release ?? 0.50) + 0.05);}catch(_){ } });
}


function drawViz(){
  if (!analyser || !meterAnalyser || !meterCv || !spectrumCv) return;

  const mctx = meterCv.getContext("2d");
  const sctx = spectrumCv.getContext("2d");

  // Meter RMS from time domain
  const tbuf = new Float32Array(meterAnalyser.fftSize);
  meterAnalyser.getFloatTimeDomainData(tbuf);
  let sum = 0;
  for (let i=0;i<tbuf.length;i++){ sum += tbuf[i]*tbuf[i]; }
  const rms = Math.sqrt(sum / tbuf.length);
  const db = 20 * Math.log10(rms + 1e-8);
  const norm = clamp((db + 60) / 60, 0, 1);

  mctx.clearRect(0,0,meterCv.width,meterCv.height);
  mctx.fillStyle = "rgba(255,255,255,0.10)";
  mctx.fillRect(0,0,meterCv.width,meterCv.height);
  mctx.fillStyle = "rgba(52,211,153,0.55)";
  mctx.fillRect(0,0,meterCv.width*norm,meterCv.height);
  mctx.fillStyle = "rgba(255,255,255,0.8)";
  mctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  mctx.fillText(`Level: ${db.toFixed(1)} dB`, 10, 14);

  // AUTO-SAFETY: if it gets too hot, duck master a bit
  if (db > -6 && master && ac){
    const t = ac.currentTime;
    const g = Math.max(0.15, master.gain.value * 0.85);
    master.gain.cancelScheduledValues(t);
    master.gain.setValueAtTime(master.gain.value, t);
    master.gain.linearRampToValueAtTime(g, t + 0.04);
  }


  // Spectrum
  const fbuf = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(fbuf);
  sctx.clearRect(0,0,spectrumCv.width,spectrumCv.height);
  sctx.fillStyle = "rgba(255,255,255,0.08)";
  sctx.fillRect(0,0,spectrumCv.width,spectrumCv.height);

  const w = spectrumCv.width;
  const h = spectrumCv.height;
  const bins = fbuf.length;
  // draw 256 bars max
  const bars = 256;
  for (let i=0;i<bars;i++){
    const idx = Math.floor(i * bins / bars);
    const v = fbuf[idx] / 255;
    const bh = v * (h-10);
    const x = (i / bars) * w;
    const bw = w / bars;
    sctx.fillStyle = `rgba(255,255,255,${0.10 + 0.55*v})`;
    sctx.fillRect(x, h-bh, bw, bh);
  }
}

function bpm(){ return clamp(parseFloat(bpmEl.value || "100"), 60, 180); }
function bars(){ return parseInt(barsSel.value, 10); }
function beatsPerBar(){ return 4; }
function loopBeats(){ return bars() * beatsPerBar(); }
function mtof(m){ return 440 * Math.pow(2, (m - 69) / 12); }
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

function ensureMasterAudible(){
  if (master && ac){
    if (master.gain.value < 0.15) master.gain.value = 0.78;
  }
}

function ensureAudio(){
  if (ac) return;
  ac = new (window.AudioContext || window.webkitAudioContext)();

  master = ac.createGain();
  master.gain.value = 0.78;

  dry = ac.createGain();
  wet = ac.createGain();
  dry.gain.value = 1.0;
  wet.gain.value = parseFloat(revEl.value);

  convolver = ac.createConvolver();
  convolver.buffer = makeImpulse(ac, 1.8, 2.0);

  dry.connect(master);
  wet.connect(convolver);
  convolver.connect(master);
  buildLimiterChain(ac, master);

  audioState.textContent = "Audio: on";
  if (!vizTimer){ vizTimer = setInterval(drawViz, 50); }
}

function makeImpulse(ctx, seconds, decay){
  const rate = ctx.sampleRate;
  const length = Math.floor(rate * seconds);
  const impulse = ctx.createBuffer(2, length, rate);
  for (let c = 0; c < 2; c++) {
    const ch = impulse.getChannelData(c);
    for (let i = 0; i < length; i++) {
      const t = i / length;
      ch[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
    }
  }
  return impulse;
}

function makeNoiseBuffer(ctx, durationSec=0.03){
  const len = Math.max(1, Math.floor(ctx.sampleRate * durationSec));
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i=0;i<len;i++){
    d[i] = (Math.random()*2-1) * (1 - (i/len)); // quick fade
  }
  return buf;
}

function pluckNote(ctx, outDry, outWet, freq, when, durSec, vol, preset){
  const t0 = when ?? ctx.currentTime;
  const v = clamp(vol ?? 1, 0, 1);
  const p = preset || { brightness:0.5, decay:0.5, damp:0.25 };

  // Exciter: short noise burst through a brightness filter
  const noise = ctx.createBufferSource();
  noise.buffer = makeNoiseBuffer(ctx, 0.028);

  const exciteLP = ctx.createBiquadFilter();
  exciteLP.type = "lowpass";
  exciteLP.frequency.setValueAtTime(800 + 4200 * p.brightness, t0);

  const exciteGain = ctx.createGain();
  exciteGain.gain.setValueAtTime(0.0001, t0);
  exciteGain.gain.exponentialRampToValueAtTime(0.9 * v, t0 + 0.003);
  exciteGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.03);

  // Delay loop (Karplus-Strong)
  const delay = ctx.createDelay();
  delay.delayTime.setValueAtTime(1 / Math.max(40, freq), t0);

  const fb = ctx.createGain();
  // feedback controls decay
  const fbVal = clamp(0.92 - 0.25 * p.damp + 0.02 * (p.decay ?? 0.5), 0.65, 0.93);
  fb.gain.setValueAtTime(fbVal, t0);

  const loopLP = ctx.createBiquadFilter();
  loopLP.type = "lowpass";
  const loopHP = ctx.createBiquadFilter();
  loopHP.type = "highpass";
  loopHP.frequency.setValueAtTime(60, t0);
  loopHP.Q.setValueAtTime(0.7, t0);

  loopLP.frequency.setValueAtTime(1200 + 2600 * p.brightness, t0);
  loopLP.Q.setValueAtTime(0.6, t0);

  // Output gain envelope
  const out = ctx.createGain();
  out.gain.setValueAtTime(0.0001, t0);
  out.gain.exponentialRampToValueAtTime(0.65 * v, t0 + 0.008);

  const stopAt = t0 + (durSec ?? 0.8);
  out.gain.exponentialRampToValueAtTime(0.0001, stopAt + 0.02);

  // Wire: exciter -> delay -> filter -> out -> dry/wet
  noise.connect(exciteLP);
  exciteLP.connect(exciteGain);
  exciteGain.connect(delay);

  delay.connect(loopLP);
  loopLP.connect(loopHP);
  loopHP.connect(out);
  out.connect(outDry);
  out.connect(outWet);

  // Feedback loop
  loopHP.connect(fb);
  fb.connect(delay);

  noise.start(t0);
  noise.stop(t0 + 0.06);

  return () => {
    // Let envelope handle the fade; no hard stop needed
  };
}

function pianoNote(ctx, outDry, outWet, freq, when, durSec, vol, preset){
  const t0 = when ?? ctx.currentTime;
  const v = clamp(vol ?? 1, 0, 1);
  const p = preset;

  const env = ctx.createGain();
  env.gain.setValueAtTime(0.0001, t0);
  env.gain.exponentialRampToValueAtTime(0.85 * v, t0 + p.attack);
  env.gain.exponentialRampToValueAtTime(Math.max(0.001, p.sustain) * v, t0 + p.attack + p.decay);

  const lp = ctx.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.setValueAtTime(p.cutoff ?? 1800, t0);
  lp.Q.setValueAtTime(0.7, t0);

  env.connect(lp);
  lp.connect(drySend);
  lp.connect(wetSend);

  // Additive-ish stack for piano body
  const partials = [1, 2, 3, 4];
  const gains = [1.0, 0.45, 0.22, 0.12];

  const oscs = [];
  partials.forEach((m, i) => {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(freq * m, t0);
    osc.detune.value = (i - 1.5) * 2; // tiny detune for width
    g.gain.value = (p.voiceGain ?? 0.26) * gains[i];
    osc.connect(g);
    g.connect(env);
    osc.start(t0);
    oscs.push(osc);
  });

  // Hammer noise click
  if ((p.hammer ?? 0) > 0.001){
    const n = ctx.createBufferSource();
    n.buffer = makeNoiseBuffer(ctx, 0.012);
    const nBP = ctx.createBiquadFilter();
    nBP.type = "bandpass";
    nBP.frequency.setValueAtTime(2600, t0);
    nBP.Q.setValueAtTime(2.2, t0);
    const ng = ctx.createGain();
    ng.gain.setValueAtTime((p.hammer * 0.8) * v, t0);
    n.connect(nBP); nBP.connect(ng); ng.connect(env);
    n.start(t0);
    n.stop(t0 + 0.02);
  }

  const stopAt = t0 + (durSec ?? 0.9);
  env.gain.exponentialRampToValueAtTime(0.0001, stopAt + (p.release ?? 0.6));

  oscs.forEach(o => { try{ o.stop(stopAt + (p.release ?? 0.6) + 0.05); } catch(_){} });

  return () => {};
}


function getPreset(instrumentId){
  const id = instrumentId || "classic_piano";

  if (id === "classic_piano"){
    return {
      engine:"harm",
      harm:[1.00,0.55,0.28,0.16,0.10,0.06],
      types:["triangle","triangle","triangle","sine","sine","sine"],
      detune:2,
      voiceGain:0.22,
      attack:0.004, decay:0.22, sustain:0.38, release:0.75,
      cutoff:2400, lpQ:0.75,
      noise:0.10, noiseDur:0.012, noiseF:2800, noiseQ:2.0,
      res:[{f:520,q:1.1,g:2.0},{f:1150,q:1.4,g:1.4}],
      drive:0.0
    };
  }
  if (id === "soft_piano"){
    return {
      engine:"harm",
      harm:[1.00,0.42,0.20,0.10,0.05],
      types:["triangle","triangle","sine","sine","sine"],
      detune:1.2,
      voiceGain:0.20,
      attack:0.010, decay:0.35, sustain:0.28, release:0.95,
      cutoff:1800, lpQ:0.7,
      noise:0.05, noiseDur:0.010, noiseF:2400, noiseQ:1.6,
      res:[{f:420,q:1.0,g:1.5},{f:980,q:1.3,g:1.0}],
      drive:0.0
    };
  }

  if (id === "warm_pad"){
    return { engine:"osc", type:"sine", cutoff:950, attack:0.04, decay:0.10, sustain:0.92, release:0.55, voiceGain:0.30 };
  }
  if (id === "bright_synth"){
    return { engine:"osc", type:"sawtooth", cutoff:1700, attack:0.012, decay:0.08, sustain:0.75, release:0.22, voiceGain:0.22 };
  }

  if (id === "acoustic_guitar"){
    return {
      engine:"pluck",
      brightness:0.62, decay:0.55, damp:0.28,
      // pluck voiceGain handled per chord
      

      harm:[1.00,0.75,0.55,0.35,0.22,0.14],
      types:["triangle","sawtooth","sawtooth","triangle","sine","sine"],
      detune:0.0,
      voiceGain:0.14,
      attack:0.004, decay:0.18, sustain:0.18, release:0.32,
      cutoff:2600, lpQ:0.6,
      noise:0.12, noiseDur:0.018, noiseF:1900, noiseQ:1.2,
      res:[{f:180,q:1.0,g:5.0},{f:700,q:1.2,g:3.5},{f:2200,q:1.0,g:2.2}],
      drive:0.15
    };
  }
  if (id === "electric_guitar"){
    return {
      engine:"pluck",
      brightness:0.72, decay:0.48, damp:0.22,
      

      harm:[1.00,0.85,0.60,0.40,0.25,0.16,0.10],
      types:["sawtooth","sawtooth","triangle","triangle","sine","sine","sine"],
      detune:0.0,
      voiceGain:0.12,
      attack:0.003, decay:0.14, sustain:0.24, release:0.26,
      cutoff:3200, lpQ:0.55,
      noise:0.08, noiseDur:0.014, noiseF:2400, noiseQ:1.4,
      res:[{f:140,q:0.9,g:4.2},{f:900,q:1.1,g:2.8},{f:2600,q:1.0,g:2.6}],
      drive:0.28
    };
  }

  if (id === "bass_guitar"){
    return {
      engine:"pluck",
      brightness:0.35, decay:0.7, damp:0.4,
      

      harm:[1.00,0.25,0.12,0.05],
      types:["sine","triangle","triangle","sine"],
      detune:0.0,
      voiceGain:0.28,
      attack:0.010, decay:0.20, sustain:0.78, release:0.22,
      cutoff:650, lpQ:0.9,
      noise:0.02, noiseDur:0.010, noiseF:900, noiseQ:1.0,
      res:[{f:90,q:0.9,g:4.5},{f:220,q:1.1,g:2.0}],
      drive:0.08
    };
  }

  return { engine:"osc", type:"triangle", cutoff:1400, attack:0.01, decay:0.08, sustain:0.7, release:0.25, voiceGain:0.22 };
}

function startChord(ctx, outDry, outWet, freqs, when, volumeMul, instrumentId, strumOn, revSend){
  const t0 = when ?? ctx.currentTime;
  const vol = clamp(volumeMul ?? 1, 0, 1);
  let preset = getPreset(instrumentId);
  const meta = instrumentMeta(instrumentId || (soundSel ? soundSel.value : "classic_piano"));
  const doStrum = !!strumOn && meta.supportsStrum && freqs.length > 1;
  const strumStep = 0.018; // seconds between notes
  const rs = clamp((revSend ?? 0.22), 0, 1);
  const drySend = ctx.createGain();
  drySend.gain.setValueAtTime(1.0, t0);
  const wetSend = ctx.createGain();
  wetSend.gain.setValueAtTime(rs, t0);
  drySend.connect(outDry);
  wetSend.connect(outWet);

  if (safeMode && preset.engine === "pluck"){
    // Safety mode: keep pluck character but force heavy damping.
    preset = { ...preset, damp: Math.max(0.55, preset.damp ?? 0.35), brightness: Math.min(0.55, preset.brightness ?? 0.45) };
  }

  // Pluck engine (guitar/bass)
  if (preset.engine === "pluck"){
    freqs.forEach((f, idx) => {
      const w = t0 + (doStrum ? idx * strumStep : 0);
      pluckNote(ctx, drySend, wetSend, f, w, 1.2, vol, preset);
    });
    return () => {};
  }

  // Piano engine
  if (preset.engine === "piano"){
    freqs.forEach((f, idx) => {
      const w = t0 + (doStrum ? idx * strumStep : 0);
      pianoNote(ctx, drySend, wetSend, f, w, 1.4, vol, preset);
    });
    return () => {};
  }

  // Fallback osc engine
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.0001, t0);
  env.gain.exponentialRampToValueAtTime(0.78 * vol, t0 + (preset.attack ?? 0.01));

  const lp = ctx.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.setValueAtTime(preset.cutoff ?? 1400, t0);
  lp.Q.setValueAtTime(0.6, t0);

  env.connect(lp);
  lp.connect(drySend);
  lp.connect(wetSend);

  const oscs = [];
  freqs.forEach((f, idx) => {
    const osc = ctx.createOscillator();
    const g   = ctx.createGain();
    osc.type = preset.type ?? "triangle";
    osc.detune.value = (idx - 1) * 4;
    g.gain.value = preset.voiceGain ?? 0.28;
    osc.frequency.setValueAtTime(f, t0);
    osc.connect(g);
    g.connect(env);
    osc.start(t0 + (doStrum ? (idx * strumStep) : 0));
    oscs.push(osc);
  });

  const stop = (atTime) => {
    const t1 = atTime ?? ctx.currentTime;
    env.gain.cancelScheduledValues(t1);
    env.gain.setValueAtTime(Math.max(env.gain.value, 0.0001), t1);
    env.gain.exponentialRampToValueAtTime(0.0001, t1 + (preset.release ?? 0.25));
    const stopAt = t1 + (preset.release ?? 0.25) + 0.05;
    oscs.forEach(o => { try { o.stop(stopAt); } catch(_){} });
  };

  return stop;
}

function playScheduled(ctx, outDry, outWet, freqs, when, durSec, volumeMul, instrumentId, strumOn, revSend){
  const stop = startChord(ctx, outDry, outWet, freqs, when, volumeMul, instrumentId, strumOn, revSend);
  stop((when ?? ctx.currentTime) + (durSec ?? 0.9));
}

function formatChordLabel(root, qual){
  if (qual === "maj") return root;
  if (qual === "min") return root + "m";
  if (qual === "dim") return root + "dim";
  return root;
}

function chordForPad(padIndex, keyName){
  const tonicIdx = NOTE_NAMES.indexOf(keyName);
  const degree   = (padIndex === 7) ? 0 : padIndex;
  const rootSemis= (tonicIdx + MAJOR_SCALE[degree]) % 12;
  const qual     = DEGREE_QUAL[padIndex];

  const tri = TRIADS[qual] || TRIADS.maj;
  const baseMidiRoot = 48 + rootSemis;
  const midiRoot = (padIndex === 7) ? baseMidiRoot + 12 : baseMidiRoot;

  const midis = tri.map(x => midiRoot + x);
  const freqs = midis.map(mtof);

  const rootName = NOTE_NAMES[rootSemis];
  const label = formatChordLabel(rootName, qual);
  const notes = midis.map(m => NOTE_NAMES[m % 12]).join(" - ");
  const symbol = chordSymbol(rootName, qual);
  return { label, symbol, notes, freqs, rootMidi: midiRoot, rootName, qual, degree, keyName };
}

function freqsForRole(role, chordObj){
  if (role === "bass"){
    const bassMidi = chordObj.rootMidi - 12;
    return [mtof(bassMidi)];
  }
  if (role === "lead"){
    return [chordObj.freqs[chordObj.freqs.length - 1]];
  }
  return chordObj.freqs;
}

// pads

const C5_KEYS = ["C","G","D","A","E","B","F#","C#","G#","D#","A#","F"].map(prettyAccidentals);
const C5_MAP_RAW = {"C":"C","G":"G","D":"D","A":"A","E":"E","B":"B","F#":"F♯","C#":"C♯","G#":"G♯","D#":"D♯","A#":"A♯","F":"F"};
let c5SegByKey = {};

function polar(cx, cy, r, ang){
  return [cx + r*Math.cos(ang), cy + r*Math.sin(ang)];
}

function arcPath(cx, cy, r0, r1, a0, a1){
  const [x0,y0] = polar(cx,cy,r1,a0);
  const [x1,y1] = polar(cx,cy,r1,a1);
  const [x2,y2] = polar(cx,cy,r0,a1);
  const [x3,y3] = polar(cx,cy,r0,a0);
  const large = (a1-a0) > Math.PI ? 1 : 0;
  return `M ${x0} ${y0} A ${r1} ${r1} 0 ${large} 1 ${x1} ${y1} L ${x2} ${y2} A ${r0} ${r0} 0 ${large} 0 ${x3} ${y3} Z`;
}

function initCircleOfFifths(){
  if (!circleSvg) return;
  circleSvg.innerHTML = "";
  c5SegByKey = {};

  const cx=110, cy=110, r0=58, r1=102;
  const segN=12;
  const start = -Math.PI/2; // top
  const step = (Math.PI*2)/segN;

  // segments
  for (let i=0;i<segN;i++){
    const a0 = start + i*step;
    const a1 = start + (i+1)*step;

    const key = C5_KEYS[i];
    const p = document.createElementNS("http://www.w3.org/2000/svg","path");
    p.setAttribute("d", arcPath(cx,cy,r0,r1,a0,a1));
    p.setAttribute("class","c5-seg");
    circleSvg.appendChild(p);
    c5SegByKey[key] = p;

    // text
    const mid = (a0+a1)/2;
    const [tx,ty] = polar(cx,cy,(r0+r1)/2, mid);
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x", tx.toFixed(2));
    t.setAttribute("y", ty.toFixed(2));
    t.setAttribute("text-anchor","middle");
    t.setAttribute("dominant-baseline","middle");
    t.setAttribute("class","c5-text");
    t.textContent = key;
    circleSvg.appendChild(t);
  }

  // center chord symbol + label
  const center = document.createElementNS("http://www.w3.org/2000/svg","text");
  center.setAttribute("x","110"); center.setAttribute("y","115");
  center.setAttribute("text-anchor","middle");
  center.setAttribute("class","c5-center");
  center.setAttribute("id","c5Center");
  center.textContent = "—";
  circleSvg.appendChild(center);

  const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
  sub.setAttribute("x","110"); sub.setAttribute("y","140");
  sub.setAttribute("text-anchor","middle");
  sub.setAttribute("class","c5-sub");
  sub.setAttribute("id","c5Sub");
  sub.textContent = "";
  circleSvg.appendChild(sub);
}

function highlightKeyOnCircle(keyName){
  const kPretty = prettyAccidentals(keyName);
  Object.values(c5SegByKey).forEach(el => el.classList.remove("active"));
  if (c5SegByKey[kPretty]) c5SegByKey[kPretty].classList.add("active");
}

function setChordDisplay(chordObj){
  const sym = chordObj?.symbol || chordObj?.label || "—";
  if (learnChordEl) learnChordEl.textContent = sym;
  const c = document.getElementById("c5Center");
  if (c) c.textContent = sym;
  const s = document.getElementById("c5Sub");
  if (s) s.textContent = prettyAccidentals(chordObj?.keyName || keySel?.value || "");
}


function setPadActive(i, on){
  const el = padButtons[i];
  if (!el) return;
  el.classList.toggle("active", !!on);
  if (on) setTimeout(() => el.classList.remove("active"), 120);
}

// tracks
const TRACK_COLORS = ["#60a5fa","#34d399","#fbbf24","#fb7185","#a78bfa","#f97316","#22c55e","#e879f9"];

const INSTRUMENTS = [
  { value:"classic_piano",   label:"Classic Piano",   supportsStrum:false },
  { value:"soft_piano",      label:"Soft Piano",      supportsStrum:false },
  { value:"warm_pad",        label:"Warm Pad",        supportsStrum:false },
  { value:"bright_synth",    label:"Bright Synth",    supportsStrum:false },
  { value:"acoustic_guitar", label:"Acoustic Guitar", supportsStrum:true  },
  { value:"electric_guitar", label:"Electric Guitar", supportsStrum:true  },
  { value:"bass_guitar",     label:"Bass Guitar",     supportsStrum:false },
  { value:"drum_kit", label:"Drum Kit", supportsStrum:false },
];

function instrumentMeta(id){
  return INSTRUMENTS.find(x => x.value === id) || INSTRUMENTS[0];
}

const ROLES = [
  { value:"chord", label:"Chord" },
  { value:"bass",  label:"Bass" },
  { value:"lead",  label:"Lead" },
  { value:"drums", label:"Drums" },
];


function ensureDrumTrack(){
  // prefer armed if already drums
  const armed = tracks.find(t=>t.id===armedTrackId);
  if (armed && armed.role==="drums") return armed;

  let dt = tracks.find(t=>t.role==="drums");
  if (!dt){
    addTrack("Drums");
    dt = tracks[tracks.length-1];
    dt.role = "drums";
    dt.instrument = "drum_kit";
    dt.rev = 0.12;
    dt.vol = 0.95;
  }
  setArmedTrack(dt.id);
  renderTracks();
  return dt;
}

function applyDrumPattern(kind){
  const t = ensureDrumTrack();
  t.events = [];
  t.lastScheduledAbs = {};
  const lb = loopBeats();
  const step = 0.5; // 1/8 notes
  const ev = (tBeats, padId, dBeats=0.25)=>{
    t.events.push({ id: nextEventId++, tBeats, padId, dBeats, kind:"drum", key: keySel.value });
  };

  if (kind === "rock"){
    // hats 1/8
    for (let b=0; b<lb; b+=step) ev(b, 18, 0.20);         // hat
    for (let bar=0; bar<bars(); bar++){
      const o = bar*4;
      ev(o+0.0, 16, 0.25); // kick
      ev(o+2.0, 16, 0.25); // kick
      ev(o+1.0, 17, 0.25); // snare
      ev(o+3.0, 17, 0.25); // snare
    }
  } else {
    // hiphop: hats 1/8 + a little off-kick
    for (let b=0; b<lb; b+=step) ev(b, 18, 0.18);
    for (let bar=0; bar<bars(); bar++){
      const o = bar*4;
      ev(o+0.0, 16, 0.25);  // kick
      ev(o+1.5, 16, 0.25);  // kick off-beat
      ev(o+2.5, 16, 0.25);  // kick
      ev(o+1.0, 17, 0.25);  // snare
      ev(o+3.0, 17, 0.25);  // snare
      ev(o+3.5, 20, 0.20);  // clap accent
    }
  }

  renderTicks();
  updateLoopBadge();
  renderTracks();
}

function addTrack(name){
  const id = uid();
  const color = TRACK_COLORS[tracks.length % TRACK_COLORS.length];
  const t = { id, name: name ?? `Track ${tracks.length + 1}`, color, role:"chord", instrument:"classic_piano", strum:false, rev:0.22, events: [], muted:false, armed:false, vol:1.00, lastScheduledAbs:{} };
  tracks.push(t);
  if (!armedTrackId) setArmedTrack(id);
  renderTracks();
  updateLoopBadge();
}

function getArmedTrack(){
  return tracks.find(t => t.id === armedTrackId) || null;
}

function setArmedTrack(id){
  armedTrackId = id;
  tracks.forEach(t => t.armed = (t.id === id));
  const idx = tracks.findIndex(t => t.id === id);
  armedPill.textContent = `Armed: Track ${idx >= 0 ? (idx+1) : 1}`;
  renderTracks();
}

function clearTrack(id){
  const t = tracks.find(x => x.id === id);
  if (!t) return;
  t.events = [];
  t.lastScheduledAbs = {};
  updateLoopBadge();
  renderTracks();
}

function toggleMute(id){
  const t = tracks.find(x => x.id === id);
  if (!t) return;
  t.muted = !t.muted;
  renderTracks();
}

function clearAll(){
  tracks.forEach(t => { t.events = []; t.lastScheduledAbs = {}; });
  updateLoopBadge();
  renderTracks();
}

function renderTracks(){
  tracksEl.innerHTML = "";
  tracks.forEach((t, i) => {
    const row = document.createElement("div");
    row.className = "trackRowCompact";
    row.style.borderColor = t.color;

    const name = document.createElement("div");
    name.className = "tName";
    name.innerHTML = `<span class="dot" style="background:${t.color}"></span><span>${t.name}</span>`;

    const arm = document.createElement("button");
    arm.className = "btn tiny" + (t.armed ? " on" : "");
    arm.textContent = t.armed ? "ARM" : "Arm";
    arm.title = "Arm this track";
    arm.addEventListener("click", ()=> setArmedTrack(t.id));

    const mute = document.createElement("button");
    mute.className = "btn tiny" + (t.muted ? " on" : "");
    mute.textContent = t.muted ? "M" : "M";
    mute.title = "Mute";
    mute.addEventListener("click", ()=>{ t.muted = !t.muted; renderTracks(); });

    const roleSel = document.createElement("select");
    roleSel.className = "tinySel";
    ROLES.forEach(r => {
      const opt = document.createElement("option");
      opt.value = r.value; opt.textContent = r.label;
      if (t.role === r.value) opt.selected = true;
      roleSel.appendChild(opt);
    });
    roleSel.addEventListener("change", ()=>{
      t.role = roleSel.value;
      if (t.role === "drums") { t.instrument = "drum_kit"; t.strum = false; }
      renderTracks();
    });

    const instSel = document.createElement("select");
    instSel.className = "tinySel";
    SOUND_PRESETS.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.id; opt.textContent = s.label;
      if (t.instrument === s.id) opt.selected = true;
      instSel.appendChild(opt);
    });
    instSel.disabled = (t.role === "drums");
    instSel.addEventListener("change", ()=>{ t.instrument = instSel.value; });

    const strum = document.createElement("button");
    const meta = instrumentMeta(t.instrument);
    strum.className = "btn tiny" + (t.strum ? " on" : "");
    strum.textContent = "Str";
    strum.title = "Strum toggle (guitar/bass)";
    strum.disabled = !meta.supportsStrum || t.role === "drums";
    strum.addEventListener("click", ()=>{ t.strum = !t.strum; renderTracks(); });

    const vol = document.createElement("input");
    vol.type = "range"; vol.min="0"; vol.max="1"; vol.step="0.01";
    vol.value = String(t.vol ?? 1);
    vol.className = "tinyRange";
    vol.title = "Volume";
    vol.addEventListener("input", ()=>{ t.vol = Number(vol.value); });

    const rev = document.createElement("input");
    rev.type="range"; rev.min="0"; rev.max="1"; rev.step="0.01";
    rev.value = String(t.rev ?? 0.22);
    rev.className = "tinyRange";
    rev.title = "Reverb send";
    rev.addEventListener("input", ()=>{ t.rev = Number(rev.value); });

    const clear = document.createElement("button");
    clear.className = "btn tiny";
    clear.textContent = "Clr";
    clear.title = "Clear this track";
    clear.addEventListener("click", ()=> clearTrack(t.id));

    const hits = document.createElement("div");
    hits.className = "tHits";
    hits.textContent = t.events.length ? `${t.events.length}` : "—";
    hits.title = "Event count";

    row.appendChild(name);
    row.appendChild(arm);
    row.appendChild(mute);
    row.appendChild(roleSel);
    row.appendChild(instSel);
    row.appendChild(strum);
    row.appendChild(vol);
    row.appendChild(rev);
    row.appendChild(hits);
    row.appendChild(clear);
    tracksEl.appendChild(row);
  });
}

function wrapCtl(label, el){
  const box = document.createElement("div");
  box.style.display = "grid";
  box.style.gap = "6px";
  const l = document.createElement("div");
  l.className = "smallLabel";
  l.textContent = label;
  box.appendChild(l);
  box.appendChild(el);
  return box;
}

function updateLoopBadge(){
  const total = tracks.reduce((s,t)=>s+t.events.length,0);
  loopBadge.textContent = total ? "LOOP" : "EMPTY";
}

// timing
function quantizeBeat(beat, grid = 0.25){
  return Math.round(beat / grid) * grid;
}
function beatsToSeconds(beats){
  const bps = bpm() / 60;
  return beats / bps;
}
function nowBeats(){
  if (!ac) return 0;
  const sec = ac.currentTime - loopStartTime;
  const bps = bpm() / 60;
  return sec * bps;
}

// playback (no duplicates)
function scheduleLoopPlayback(){
  clearInterval(playTimer);
  if (!ac) return;

  updateLoopBadge();
  loopInfo.textContent = `Loop: ${bars()} bars • Quantize: ON`;
renderTicks();

  playTimer = setInterval(() => {
    if (!isPlaying || !ac) return;

    const bps = bpm() / 60;
    const tNow = ac.currentTime;
    const absBeatNow = nowBeats();     // absolute beats since loopStartTime
    const lb = loopBeats();
    const lookaheadSec = 0.14;
    const lookaheadBeats = lookaheadSec * bps;

    tracks.forEach(track => {
      if (track.muted) return;
      if (isRecording && track.id === armedTrackId) return; // monitor fix

      track.events.forEach(ev => {
        const tInLoop = (ev.tBeats % lb + lb) % lb;

        // compute next absolute occurrence
        let base = Math.floor(absBeatNow / lb) * lb;
        let nextAbs = base + tInLoop;
        if (nextAbs < absBeatNow - 0.0001) nextAbs += lb;

        const delta = nextAbs - absBeatNow;
        if (delta <= lookaheadBeats){
          const lastAbs = track.lastScheduledAbs[ev.id];
          if (lastAbs === nextAbs) return; // already scheduled this occurrence
          track.lastScheduledAbs[ev.id] = nextAbs;

          const when = tNow + (delta / bps);
          
          const kind = ev.kind || ((ev.padId ?? ev.padIndex ?? 0) >= 16 ? "drum" : "chord");
          if (kind === "drum" || track.role === "drums"){
            const pid = (ev.padId ?? (ev.padIndex + 16)) ?? 16;
            const def = getPadDef(pid, ev.key || keySel.value);
            const dtype = def?.drumType || "hat";
            drumHit(ac, dry, wet, dtype, when, track.vol, track.rev);
          } else {
            const pid = (ev.padId ?? ev.padIndex) ?? 0;
            const def = getPadDef(pid, ev.key || keySel.value);
            if (!def) return;
            const freqs = freqsForRole(track.role, def);
            const durSec = beatsToSeconds(ev.dBeats ?? 1.0);
            playScheduled(ac, dry, wet, freqs, when, durSec, track.vol, track.instrument, track.strum, track.rev);
          }

        }
      });
    });
  }, 35);

  cancelAnimationFrame(rafId);
  const tick = () => {
    if (!isPlaying || !ac) return;
    const lb = loopBeats();
    const beatNow = nowBeats();
    const frac = (beatNow % lb) / lb;
    const w = blocks.clientWidth;
    playhead.style.transform = `translateX(${Math.floor(frac * w)}px)`;
    rafId = requestAnimationFrame(tick);
  };
  rafId = requestAnimationFrame(tick);
}

// record + sustain
function padHoldStart(padId, pointerId){
  ensureAudio();
  if (ac && ac.state === "suspended") ac.resume();

  setPadActive(padId, true);

  const def = getPadDef(padId, keySel.value);
  const lb = loopBeats();

  // Choose destination track: chords -> armed non-drum, drums -> armed drum
  const armed = getArmedTrack();
  const dest = pickTrackForPad(def, armed);

  // Live sound (always)
  let stopFn = () => {};
  try{
    if (def.kind === "drum"){
      drumHit(ac, drySend, wetSend, def.drumType, ac.currentTime, (dest?.vol ?? 1.0), (dest?.rev ?? 0.22));
      stopFn = () => {};
    } else {
      const inst = (dest?.instrument ?? "classic_piano");
      stopFn = startChord(ac, drySend, wetSend, def.freqs, ac.currentTime, (dest?.vol ?? 1.0), inst, (dest?.strum ?? false), (dest?.rev ?? 0.22));
      lastChord.textContent = `Last: ${def.label}`;
      highlightKeyOnCircle(def.rootName);
      setChordDisplay(def);
    }
  } catch(e){ showErr(e); }

  activeHolds.set(pointerId, { stopFn, padId, trackId: dest?.id ?? null, startBeat: null, recId: null });

  // Recording (only when transport is rolling)
  if (isRecording && isPlaying && dest){
    const b = nowBeats();
    const q = quantizeBeat(b, 0.25) % lb;
    const id = nextEventId++;
    const dBeats = (def.kind === "drum") ? 0.25 : 1.0;
    dest.events.push({ id, tBeats: q, padId, dBeats, kind: def.kind, key: keySel.value });
    const hold = activeHolds.get(pointerId);
    if (hold){ hold.startBeat = q; hold.recId = id; hold.trackId = dest.id; }
    updateLoopBadge();
    renderTracks();
  }
}

function padHoldEnd(pointerId){
  const hold = activeHolds.get(pointerId);
  if (!hold) return;

  try { hold.stopFn(ac ? ac.currentTime : undefined); } catch(_){}
  setPadActive(hold.padId, false);

  if (hold.recId && isRecording && isPlaying){
    const lb = loopBeats();
    const nowB = (nowBeats() % lb + lb) % lb;
    let d = nowB - (hold.startBeat ?? 0);
    if (d < 0) d += lb;
    d = clamp(quantizeBeat(d, 0.25), 0.25, lb);

    const track = tracks.find(t => t.id === hold.trackId);
    if (track){
      const ev = track.events.find(e => e.id === hold.recId);
      if (ev && ev.kind !== "drum") ev.dBeats = d;
    }
  }

  activeHolds.delete(pointerId);
}

// transport
function start(){
  ensureAudio();
  if (ac.state === "suspended") ac.resume();

  isPlaying = true;
  loopStartTime = ac.currentTime;

  // reset scheduling guards each start (fresh loopStart)
  tracks.forEach(t => t.lastScheduledAbs = {});

  playBtn.classList.add("on");
  modePill.textContent = isRecording ? "Mode: Record" : "Mode: Play";
  scheduleLoopPlayback();
}

function stop(){
  isPlaying = false;
  isRecording = false;

  playBtn.classList.remove("on");
  recBtn.classList.remove("on");
  modePill.textContent = "Mode: Play";

  clearInterval(playTimer);
  playTimer = null;
  cancelAnimationFrame(rafId);

  playhead.style.transform = `translateX(0px)`;
  [...activeHolds.keys()].forEach(pid => padHoldEnd(pid));
}

function clearArmed(){
  const a = getArmedTrack();
  if (!a) return;
  a.events = [];
  updateLoopBadge();
  renderTracks();
}

function panic(){
  // Stop transport and kill any held voices safely
  try{ stop(); }catch(_){ }
  try{
    activeHolds.forEach((h, pid)=>{
      try{ h.stopFn(ac ? ac.currentTime : undefined); }catch(_){ }
    });
    activeHolds.clear();
  }catch(_){ }
  if (master && ac){
    const t = ac.currentTime;
    master.gain.cancelScheduledValues(t);
    master.gain.setValueAtTime(master.gain.value, t);
    master.gain.exponentialRampToValueAtTime(0.0001, t + 0.04);
    setTimeout(()=>{ try{ master.gain.value = 1.0; }catch(_){} }, 80);
  }
  // Clear pad states
  for (let i=0;i<24;i++) setPadActive(i,false);
}


function toggleRecord(){
  if (!isPlaying) start();
  isRecording = !isRecording;
  recBtn.classList.toggle("on", isRecording);
  modePill.textContent = isRecording ? "Mode: Record" : "Mode: Play";
}

// Bounce (one loop cycle)
async function bounceWav(){
  const lb = loopBeats();
  const sr = 44100;
  const durationSec = beatsToSeconds(lb);

  const off = new OfflineAudioContext(2, Math.ceil(durationSec * sr), sr);

  const master = off.createGain();
  master.gain.value = 0.95;

  const dry = off.createGain();
  const wet = off.createGain();
  dry.gain.value = 1.0;
  wet.gain.value = parseFloat(revEl.value);

  const convolver = off.createConvolver();
  convolver.buffer = makeImpulse(off, 1.8, 2.0);

  dry.connect(master);
  wet.connect(convolver);
  convolver.connect(master);
  master.connect(off.destination);

  tracks.forEach(track => {
    if (track.muted) return;
    track.events.forEach(ev => {
      const whenSec = beatsToSeconds(ev.tBeats);
      const chordObj = chordForPad(ev.padIndex, keySel.value);
      const freqs = freqsForRole(track.role, chordObj);
      const durSec = beatsToSeconds(ev.dBeats ?? 1.0);
      playScheduled(off, dry, wet, freqs, whenSec, durSec, track.vol, track.instrument, track.strum, track.rev);
    });
  });

  const buf = await off.startRendering();
  const wavBlob = audioBufferToWavBlob(buf);
  const a = document.createElement("a");
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  a.download = `powerschord-bounce-${stamp}.wav`;
  a.href = URL.createObjectURL(wavBlob);
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 3000);
}

function audioBufferToWavBlob(buffer){
  const numCh = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const length = buffer.length;

  const channels = [];
  for (let c=0;c<numCh;c++) channels.push(buffer.getChannelData(c));
  const interleaved = new Float32Array(length * numCh);
  for (let i=0;i<length;i++){
    for (let c=0;c<numCh;c++){
      interleaved[i*numCh+c] = channels[c][i];
    }
  }

  const bytesPerSample = 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = interleaved.length * bytesPerSample;
  const bufferSize = 44 + dataSize;
  const dv = new DataView(new ArrayBuffer(bufferSize));

  let p=0;
  function writeStr(s){ for (let i=0;i<s.length;i++) dv.setUint8(p++, s.charCodeAt(i)); }
  function writeU32(v){ dv.setUint32(p, v, true); p+=4; }
  function writeU16(v){ dv.setUint16(p, v, true); p+=2; }

  writeStr("RIFF");
  writeU32(36 + dataSize);
  writeStr("WAVE");
  writeStr("fmt ");
  writeU32(16);
  writeU16(1);
  writeU16(numCh);
  writeU32(sampleRate);
  writeU32(byteRate);
  writeU16(blockAlign);
  writeU16(16);
  writeStr("data");
  writeU32(dataSize);

  for (let i=0;i<interleaved.length;i++){
    let s = Math.max(-1, Math.min(1, interleaved[i]));
    dv.setInt16(p, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    p += 2;
  }
  return new Blob([dv.buffer], { type:"audio/wav" });
}

safeMode = safeModeEl ? !!safeModeEl.checked : true;
if (safeModeEl){
  safeModeEl.addEventListener("change", ()=>{ safeMode = !!safeModeEl.checked; });
}

// controls
playBtn.addEventListener("click", () => {
  ensureMasterAudible(); if (!isPlaying) start(); });
stopBtn.addEventListener("click", stop);
recBtn.addEventListener("click", toggleRecord);

keySel.addEventListener("change", () => renderPads());
bpmEl.addEventListener("change", () => { bpmEl.value = String(bpm()); if (isPlaying) scheduleLoopPlayback(); });
barsSel.addEventListener("change", () => {
  const lb = loopBeats();
  tracks.forEach(t => { t.events = t.events.map(e => ({...e, tBeats: e.tBeats % lb, dBeats: Math.min(e.dBeats ?? 1.0, lb) })); t.lastScheduledAbs = {}; });
  if (isPlaying) scheduleLoopPlayback();
  loopInfo.textContent = `Loop: ${bars()} bars • Quantize: ON`;
  renderTicks();
});
revEl.addEventListener("input", () => { if (wet) wet.gain.value = parseFloat(revEl.value); });

addTrackBtn.addEventListener("click", () => addTrack());
clearAllBtn.addEventListener("click", () => clearAll());
exportBtn.addEventListener("click", () => bounceWav());
if (panicBtn){
  panicBtn.addEventListener("click", ()=>{ panic(); });
}

// keyboard shortcuts
window.addEventListener("keydown", (e) => {
  if (e.repeat) return;

  const k = (e.key || "").toLowerCase();
  const playPadByKey = (keyArr, baseId) => {
    const idx = keyArr.indexOf(k);
    if (idx < 0) return false;
    const padId = baseId + idx;
    const pid = "kbd-"+k;
    padHoldStart(padId, pid);
    // drums are one-shots; chords get a short hold
    setTimeout(() => padHoldEnd(pid), (padId >= 16 ? 60 : 140));
    return true;
  };

  if (playPadByKey(KBD_KEYS_MAJ, 0)) return;
  if (playPadByKey(KBD_KEYS_MIN, 8)) return;
  if (playPadByKey(KBD_KEYS_DRM, 16)) return;

  if (e.code === "Space"){
    e.preventDefault();
    isPlaying ? stop() : start();
  }
  if (k === "r") toggleRecord();
  if (k === "c") clearArmed();
  if (k === "escape") panic();
});\n
// init
renderPads();
  initCircleOfFifths();
  highlightKeyOnCircle(keySel.value);
  setChordDisplay(chordForPad(0, keySel.value));
addTrack("Track 1");
updateLoopBadge();
loopInfo.textContent = `Loop: ${bars()} bars • Quantize: ON`;


document.body.addEventListener('pointerdown', () => { try{ ensureAudio(); if(ac && ac.state==='suspended') ac.resume(); }catch(_){ } }, { once:false });

function buildPad(el, keyLabel, nameLabel, isDrum=false){
  const d = document.createElement("div");
  d.className = "pad" + (isDrum ? " drum" : "");
  d.innerHTML = `
    <div class="padKey">${keyLabel}</div>
    <div class="padName">${nameLabel}</div>
    <div class="padNotes"></div>
  `;
  el.appendChild(d);
  return d;
}

// v3.6.2: ALWAYS render 24 pads, no conditional logic.
function renderPads(){
  // Always render 24 pads: 8 Major + 8 Minor + 8 Drums
  if (!padGridMaj || !padGridMin || !padGridDrm) return;

  const tonic = keySel.value;
  const tonicIdx = NOTE_NAMES.indexOf(tonic);
  const fifthSemis = 7;

  const majPads = [];
  const minPads = [];
  for (let i=0;i<8;i++){
    const rootSemisMaj = (tonicIdx + (i*fifthSemis)) % 12;
    const rootNameMaj = NOTE_NAMES[rootSemisMaj];
    majPads.push(makeChordPadDef(i, rootNameMaj, "maj", "M"));

    const rootSemisMin = (rootSemisMaj + 9) % 12; // relative minor
    const rootNameMin = NOTE_NAMES[rootSemisMin];
    minPads.push(makeChordPadDef(8+i, rootNameMin, "min", "m"));
  }

  const drumPads = [];
  for (let i=0;i<8;i++){
    drumPads.push(makeDrumPadDef(16+i, DRUMS[i]));
  }

  padButtons = new Array(24).fill(null);

  const buildRow = (gridEl, defs, keys)=>{
    gridEl.innerHTML = "";
    defs.forEach((def, idx)=>{
      const btn = document.createElement("div");
      btn.className = "pad";
      btn.dataset.padId = String(def.id);
      btn.dataset.kind = def.kind;
      btn.style.background = PAD_COLORS[idx % PAD_COLORS.length];
      btn.innerHTML = `
        <div class="kbd">${keys[idx].toUpperCase()}</div>
        <div class="name">${def.label}</div>
        <div class="notes">${def.sub}</div>
      `;
      btn.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        btn.setPointerCapture(ev.pointerId);
        padHoldStart(def.id, ev.pointerId);
      });
      btn.addEventListener("pointerup", (ev) => { ev.preventDefault(); padHoldEnd(ev.pointerId); });
      btn.addEventListener("pointercancel", (ev) => padHoldEnd(ev.pointerId));
      gridEl.appendChild(btn);
      padButtons[def.id] = btn;
    });
  };

  buildRow(padGridMaj, majPads, KBD_KEYS_MAJ);
  buildRow(padGridMin, minPads, KBD_KEYS_MIN);
  buildRow(padGridDrm, drumPads, KBD_KEYS_DRM);

  // Sanity check visible pads
  const total = (padGridMaj.children.length + padGridMin.children.length + padGridDrm.children.length);
  const sanity = document.querySelector(".sanityBanner");
  if (sanity) sanity.style.opacity = (total === 24) ? "1" : "0.35";
}

</script>
</body>
</html>
